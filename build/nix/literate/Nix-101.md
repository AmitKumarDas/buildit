### Motivation
- My quick refresher guide to Nix fundamentals
- Lookup when I am stuck coding in Nix

### üôá‚Äç‚ôÄÔ∏è Shoutouts üôá‚Äç‚ôÄÔ∏è
- https://github.com/mhwombat/nix-for-numbskulls
- https://book.divnix.com/ch00-00-the-nix-package-manager.html
- https://nixos.wiki/wiki/Development_environment_with_nix-shell

### Prerequisites

```diff
@@ If nix is forgotten by your terminal @@
```
```sh
# source the profile
. /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
```

### From the Wild
```diff
@@ Assignment = vs. with @@
```
```nix
with import <nixpkgs> {};             # Instead of pkgs = import <nixpkgs> {};
writeScript "hello" ''
  #!${bash}/bin/bash                  # Dependency on bash derivation
  ${hello}/bin/hello                  # Dependency on hello derivation
''
```

```diff
@@ Get Output Path of the Derivation during Build @@
```
```sh
with import <nixpkgs> {};             # Starts with 'with'
writeScript "hello-its-me" ''
  #!${bash}/bin/bash                                        # Dependency on bash
  echo "Hello, world! This is ${placeholder "out"}"         # Dependency on SELF
''
```

### Debug Series
```diff
@@ note: impure path `/[...]' used in link @@
```
```sh
# ld is wrapped in a shell script 
# Refuses to LINK against files NOT residing IN the Nix Store 
# Ensures the PURITY of Builds
#
# Obviously this is not useful when building Locally
# To disable this behavior set
#
# NIX_ENFORCE_PURITY=0 # in the nix-shell
```

### Practices

```diff
@@ Folder Structure: Best Practices @@
@@ Override @@
```
```sh
https://av.tib.eu/media/50716 
```

```diff
@@ FROM mkDerivation TO mkShell @@
```
```diff
@@ Run against nix-shell WITHOUT stepping inside via --run @@
```
```diff
@@ nativeBuildInputs vs propagatedBuildInputs vs buildInputs @@
```
```diff
@@ mkYarnPackage # builtins.filterSource # lib.cleanSource # Removes symlinks @@
```
```sh
https://av.tib.eu/media/39618
```
    
### TIL Series
```diff
@@ nativeBuildInputs @@
```
```nix
{ pkgs ? import <nixpkgs> {} }:
pkgs.mkShell {
  # Tools Needed by the Build
  nativeBuildInputs = [ pkgs.buildPackages.ruby_2_7 ];
}
```

```diff
@@ buildInputs in mkShell @@
```
```nix
{ pkgs ? import <nixpkgs> {} }:
pkgs.mkShell {
  # Dependencies You'd Need "at run time"
  # Were you to to use nix-build not nix-shell and build whatever you were working on
  buildInputs = [
    (import ./my-expression.nix { inherit pkgs; })          # Import LOCAL Nix File
  ];
}
```

```diff
@@ For Flake projects Replace nix-shell with nix develop @@
```

```diff
@@ buildInputs in mkDerivation @@
```
```nix
{ stdenv, python }:
stdenv.mkDerivation {
  buildInputs = [ python ];
  name = "some-package";
  version = "0.0.1";
  src = /home/yourname/path/to/project; # local path, or fetchFromGitHub, etc.
}
```

```diff
@@ Invoke .nix File from CLI @@
```
```sh
# Solution
nix-shell -E 'with import <nixpkgs> { }; callPackage ./default.nix { }'
```

```diff
@@ buildInputs & nativeBuildInputs Are Important for Cross Platform Needs @@
@@ Cross Compilation Dev Environment @@
```
```sh
{ pkgs ? import <nixpkgs> { crossSystem.config = "exotic_arch-unknown-exotic_os"; } }:
```

```diff
@@ nativeBuildInputs for the NATIVE Platform @@
@@ buildInputs for FOREIGN Platform @@ 
```

### ü•§ Nix Book from DivNix ü•§

```diff
@@ What is a Build Closure? @@
```
```sh
# All Direct and Transitive Build Dependencies
# To be exact it is known as the derivations's Build Closure
```

```diff
@@ TIL: Normally, Dependencies of a Derivation are Other Derivations @@
```

```diff
@@ Create a Derivation @@
```
```sh
# Non-Flake
# nix-instantiate '<nixpkgs>' -A hello        # Instantiate
```
```sh
# Flake
# nix eval nixpkgs#hello.drvPath              # Eval
```

```diff
@@ Inspect a Derivation @@
```
```sh
# nix show-derivation /nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv
```

```diff
@@ Realise a Derivation @@
```
```sh
# Non-Flake
nix-store --realise /nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv
```
```sh
# Non-Flake
nix-build '<nixpkgs>' -A hello
```
```sh
# Flake
nix build nixpkgs#hello
```

```diff
@@ Inspect the Realisation @@
```
```sh
# tree -L 2 /nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10
```

```diff
@@ TIL: Many other commands also will realise a derivation as part of a workflow @@
```
```sh
# For example: nix-shell, nix shell, nix-env, nix run, and nix profile
```

```diff
@@ TIL: nix-build & nix build @@
```
```sh
# Above commands perform both instantiation & realisation
```

### ü•§ Nix for Numbskulls ü•§

```diff
@@ Why nix run can't find flake.nix? @@
```
```sh
# 1/ Nix flakes ONLY ‚ÄúSEES‚Äù files that are part of the REPOSITORY üßê <3 git üî•
# 2/ "git add" the needed files to the repo before building or running the flake
# -- e.g. git add flake.nix setup.py hello.py
# -- e.g. nix run
# 3/ git add flake.lock
```

```diff
@@ How to Share Code with Team? By Cajoling Them To Install Nix @@
```
```sh
# e.g. nix run "git+https://codeberg.org/mhwombat/hello-flake"
```

```diff
@@ nix shell vs nix-shell @@
```
```sh
# nix-shell builds a TEMPORARY environment on the fly without the need for a .flake file
# -- e.g. nix-shell -p python3
# -- e.g. nix-shell -p "python3.withPackages (ps: with ps; [ build ])" # python + build tool
```

```diff
@@ The non-hyphenated commands were introduced when support for flakes was added to Nix @@ üßê üìö
```

```diff
@@ Rule of Thumb @@ ü§ô
```
```sh
# Non-hyphenated commands for FLAKES
# Hyphenated commands are for everything else
```

```diff
@@ nix-shell to mkShell @@ üî• üî• üî•
```
```sh
# nix-shell -p "python3.withPackages (ps: with ps; [ build ])"
```
```nix
# vs.

devShells = rec {
  default = pkgs.mkShell {
    packages = [ (python.withPackages (ps: with ps; [ build ])) ];
  };
};
```

```diff
@@ nix shell vs. nix develop @@
@@ runtime shell vs. development shell @@
```
```sh
# nix shell makes the executable available at $PATH üí•

# nix develop does not do above
# We can, however, run the executable by specifying the path to the script
# -- e.g. ./my-script           üòì
# Alternatively:                üôÇ
# -- 1/ nix build 
# -- 2/ result/bin/my-script
# Simpler: nix run              üòç
```

```diff
@@ Don't need to INSTALL, simply RUN @@
```
```sh
# nix run "git+https://codeberg.org/mhwombat/hello-flake"
```

```diff
@@ Let flake build your SHELL environment @@
```
```sh
# nix shell "git+https://codeberg.org/mhwombat/hello-flake"
# In this shell, the command is on our $PATH üëà üëà üëà
# So we can execute the command by name within the SHELL
```

```diff
@@ Remember this is NOT INSTALL @@ üòç
```
```sh
# Nix didn‚Äôt install the package
# It merely built and placed it in a directory called the ‚ÄúNix store‚Äù
# Thus we can have multiple versions of a package without worrying about conflicts
```

```diff
@@ Locate the executable When You are In Nix Shell @@
```
```sh
# which <name-of-your- executable>
# Above will give you the nix path
# -- e.g. /nix/store/0xbn2hi6h1m5h4kc02vwffs2cydrbc0r-hello-flake/bin/hello-flake
```

```diff
@@ You Can Try This Cumbersome Invocation from Nix Path As Well @@
```
```sh
# /nix/store/0xbn2hi6h1m5h4kc02vwffs2cydrbc0r-hello-flake/bin/hello-flake
```

```diff
@@ build, install & internet @@
```
```sh
# The build step runs in a PURE environment to ensure that builds are REPRODUCIBLE
# -- This means NO INTERNET ACCESS; indeed no access to any files outside the build directory
# -- During the build & install phases, the only commands available are those provided by the Nix stdenv
# -- And the EXTERNAL DEPENDENCIES identified in the INPUTS section of the flake
```

```diff
@@ What is available during the build and install phases? @@ üíØ
@@ stdenv is available that consists of: @@
```
```sh
# - The GNU C Compiler      - configured with C and C++ support
# - GNU coreutils           - (contains a few dozen standard Unix commands) üí•
# - GNU findutils           - (contains find) üí•
# - GNU diffutils           - (contains diff, cmp) üí•
# - GNU sed
# - GNU grep
# - GNU awk
# - GNU tar
# - gzip, bzip2 and xz
# - GNU Make
# - Bash
# - The patch command
# - On Linux, stdenv also includes the patchelf utility üßê
```

```diff
@@ Following environment variables are available during build & install phases @@ üíØ
```
```sh
# $name                 - is the package name
# $src                  - refers to the source directory
# $out                  - PATH to the location in the Nix STORE where the package will be added
# $system               - system that the package is being built for
# $PWD and $TMP         - both point to a TEMPORARY BUILD DIRECTORIES
# $HOME and $PATH       - point to NONEXISTENT directories, so the build CANNOT RELY on them
```

```diff
@@ src = ./.; @@
```
```sh
# Supplies the Location of the Source Files, Relative to flake.nix
```

```diff
@@ unpackPhase = "true"; @@
```
```sh
# When a flake is accessed for the first time
# -- The Repo Contents are Fetched in the Form of a Tarball
# -- unpackPhase Variable Indicates that we Want the Tarball to be UnPacked
```

```diff
@@ buildPhase = ":"; @@
```
```sh
# Above is a no-op or "do nothing" command
```

```diff
@@ flake-utils.lib.eachDefaultSystem (system: @@
```
```sh
# If we want the package to be available for multiple systems 
# -- e.g., ‚Äúx86_64-linux‚Äù, ‚Äúaarch64-linux‚Äù, ‚Äúx86_64-darwin‚Äù, and ‚Äúaarch64-darwin‚Äù
# -- We need to define the output for each of those systems

# Often the definitions are identical, apart from the name of the system
# -- The eachDefaultSystem function allows to write a single definition 
# -- Using a variable for the system name
# The function then iterates over all default systems to GENERATE the OUTPUTS for EACH one
```

```diff
@@ Flake References @@
```
```sh
# 1/ A Git repository: git+https://github.com/NixOS/patchelf
# 2/ A specific branch of a Git repository: git+https://github.com/NixOS/patchelf?ref=master
# 3/ A specific revision of a Git repository: 
# -- git+https://github.com/NixOS/patchelf?ref=master&rev=f34751b88bd07d7f44f5cd3200fb4122bf916c7e
# 4/ A tarball: https://github.com/NixOS/patchelf/archive/master.tar.gz
```

```diff
@@ License Checks @@
```
```sh
# nix-env -qaA nixpkgs.vim --json | jq '."nixpkgs.vim".meta.license'
```

```diff
@@ Fetch the Source Tarball and Link it in the Current Directory @@
```
```sh
# nix-build '<nixpkgs>' -A vim.src
```

```diff
@@ Query Nix package versions & revision numbers @@
```
```sh
# https://lazamar.co.uk/nix-versions/
```
