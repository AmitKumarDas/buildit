#### Motivation
- My quick refresher guide to Nix fundamentals
- Lookup when I am stuck coding in Nix

#### üôá‚Äç‚ôÄÔ∏è Shoutouts üôá‚Äç‚ôÄÔ∏è
- https://github.com/mhwombat/nix-for-numbskulls
- https://book.divnix.com/ch00-00-the-nix-package-manager.html
- https://nixos.wiki/wiki/Development_environment_with_nix-shell

#### `When Nix is Forgotten at Terminal`
```sh
# source the profile
. /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
```

#### `nix & golang for the greater good`
```yaml
- A .go file having main
- https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/docker/tarsum.go

- Do check vendoring as well
- https://github.com/moby/moby/blob/master/vendor.mod

- Corresponding nix file that builds above
- https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/docker/tarsum.nix
```

#### `lowercase: lib.toLower`
```yaml
- https://github.com/NixOS/nixpkgs/commit/e28d817c9a776ff35fbea12cdbbf3916199f1af4
```

#### `let in ... with pkgs; mkShell {...}`
```nix
{ pkgs ? import ./nix/nixpkgs { } }:

let
  lab-script = pkgs.writeShellScriptBin "lab" (builtins.readFile ./bin/lab); # Embed a script
in
with pkgs;

mkShell {
  packages = [ lab-script bazel_4 buildifier buildozer nix ];
}
```

#### `No Assignment Operator i.e. = When using with`
```nix
with import <nixpkgs> {};             # Instead of pkgs = import <nixpkgs> {};
writeScript "hello" ''
  #!${bash}/bin/bash                  # Dependency on bash derivation
  ${hello}/bin/hello                  # Dependency on hello derivation
''
```

#### `Get Output Path of the Derivation during Build`

```nix
with import <nixpkgs> {};             # Starts with 'with'
writeScript "hello-its-me" ''
  #!${bash}/bin/bash                                        # Dependency on bash
  echo "Hello, world! This is ${placeholder "out"}"         # Dependency on SELF
''
```

#### `Error: impure path used in link`

```sh
# ld is wrapped in a shell script 
# Refuses to LINK against files NOT residing IN the Nix Store 
# Ensures the PURITY of Builds
#
# Obviously this is not useful when building Locally
# To disable this behavior set
#
# NIX_ENFORCE_PURITY=0 # in the nix-shell
```

#### `DIY mkDerivation to Make use of mkShell`

#### `Run against nix-shell WITHOUT stepping inside via --run`

#### `Important Three: nativeBuildInputs vs propagatedBuildInputs vs buildInputs`

####  `Removes symlink`
```yaml
- builtins.filterSource
- lib.cleanSource
```
    
#### `mkShell + nativeBuildInputs`
```nix
{ pkgs ? import <nixpkgs> {} }:
pkgs.mkShell {
  # Tools Needed by the Build
  nativeBuildInputs = [ pkgs.buildPackages.ruby_2_7 ];
}
```

#### `mkShell + buildInputs`
```nix
{ pkgs ? import <nixpkgs> {} }:
pkgs.mkShell {
  # Dependencies You'd Need "at Runtime"
  #
  # If nix-build & Not nix-shell
  # But still mkShell
  #
  # This builds whatever you were working on
  buildInputs = [
    (import ./my-expression.nix { inherit pkgs; })          # Import LOCAL Nix File
  ];
}
```

#### `TIL: For Flake projects Replace nix-shell with nix develop`

#### `mkDerivation + buildInputs`
```nix
{ stdenv, python }:
stdenv.mkDerivation {
  buildInputs = [ python ];
  name = "some-package";
  version = "0.0.1";
  src = /home/yourname/path/to/project; # local path, or fetchFromGitHub, etc.
}
```

#### `HowTo: Invoke .nix file from CLI`
```sh
nix-shell -E 'with import <nixpkgs> { }; callPackage ./default.nix { }'
```

#### `buildInputs & nativeBuildInputs Are Important for Cross Platform Needs`
```sh
{ pkgs ? import <nixpkgs> { crossSystem.config = "exotic_arch-unknown-exotic_os"; } }:
```

#### `TIL: nativeBuildInputs for the NATIVE Platform`
#### `TIL: buildInputs for FOREIGN Platform`

#### `What is a Build Closure?`
```sh
# All Direct and Transitive Build Dependencies
# To be exact it is known as the derivations's Build Closure
```

#### `TIL: Normally, Dependencies of a Derivation are Other Derivations`

#### `Create a Derivation`
```sh
# Non-Flake
# nix-instantiate '<nixpkgs>' -A hello        # Instantiate
```
```sh
# Flake
# nix eval nixpkgs#hello.drvPath              # Eval
```

#### `Inspect a Derivation`
```sh
# nix show-derivation /nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv
```

#### `Realise a Derivation`
```sh
# Non-Flake
nix-store --realise /nix/store/byqskk0549v1zz1b2a61lb7llfn4h5bw-hello-2.10.drv
```
```sh
# Non-Flake
nix-build '<nixpkgs>' -A hello
```
```sh
# Flake
nix build nixpkgs#hello
```

#### `Inspect the Realisation`
```sh
# tree -L 2 /nix/store/f4bywv8hjwl0ckv7l077pnap81h6qxw4-hello-2.10
```

#### `TIL: Many commands realise a derivation as part of a workflow`
```sh
# For example: nix-shell, nix shell, nix-env, nix run, and nix profile
```

#### `TIL: nix-build & nix build perform both Instantiation & Realisation`

#### `Why nix run can't find flake.nix?`
```sh
# 1/ Nix flakes ONLY ‚ÄúSEES‚Äù files that are part of the REPOSITORY üßê <3 git üî•
# 2/ "git add" the needed files to the repo before building or running the flake
# -- e.g. git add flake.nix setup.py hello.py
# -- e.g. nix run
# 3/ git add flake.lock
```

#### `How to Share Code with Team Minus Installations?`
```sh
# e.g. nix run "git+https://codeberg.org/mhwombat/hello-flake"
```

#### `nix shell vs nix-shell`
```sh
# nix-shell builds a TEMPORARY environment on the fly without the need for a .flake file
# -- e.g. nix-shell -p python3
# -- e.g. nix-shell -p "python3.withPackages (ps: with ps; [ build ])" # python + build tool
```

#### TIL: Non-hyphenated commands are for flakes`

#### `From nix-shell to mkShell`
```sh
# nix-shell -p "python3.withPackages (ps: with ps; [ build ])"
```
```nix
# vs.

devShells = rec {
  default = pkgs.mkShell {
    packages = [ (python.withPackages (ps: with ps; [ build ])) ];
  };
};
```

#### `TIL: nix shell vs. nix develop`
```yaml
- runtime shell vs. development shell
```
```sh
# nix shell makes the executable available at $PATH üí•

# nix develop does not do above

# We can, however, run the executable by specifying the path to the script
# -- e.g. ./my-script           üòì
# Alternatively:                üôÇ
# -- 1/ nix build 
# -- 2/ result/bin/my-script

# Simpler: nix run              üòç
```

#### `Don't need to INSTALL, simply RUN`
```sh
# nix run "git+https://codeberg.org/mhwombat/hello-flake"
```

#### `Let flake build your SHELL environment`
```sh
# nix shell "git+https://codeberg.org/mhwombat/hello-flake"
# In this shell, the command is on our $PATH üëà üëà üëà
# So we can execute the command by name within the SHELL
```

#### `Remember this is NOT INSTALL`
```yaml
- Nix didn‚Äôt install the package
- It merely built and placed it in a directory called the ‚ÄúNix store‚Äù
- Thus we can have multiple versions of a package without worrying about conflicts
```

#### `How to Locate the executable When You are In Nix Shell`
```sh
# which <name-of-your-executable>
# Above will give you the nix path
# -- e.g. /nix/store/0xbn2hi6h1m5h4kc02vwffs2cydrbc0r-hello-flake/bin/hello-flake
```


#### `TIL: build, install & internet`
```yaml
- The build step runs in a PURE environment to ensure that builds are REPRODUCIBLE
  - i.e. NO INTERNET ACCESS
  - No access to any files outside the build directory
- During the build & install phases, the only commands available are those provided by the Nix stdenv
- And the EXTERNAL DEPENDENCIES identified in the INPUTS section of the flake
```

#### `What is available during the build and install phases?`
```yaml
- stdenv is available 
- It consists of:
```
```sh
# - The GNU C Compiler      - configured with C and C++ support
# - GNU coreutils           - (contains a few dozen standard Unix commands) üí•
# - GNU findutils           - (contains find) üí•
# - GNU diffutils           - (contains diff, cmp) üí•
# - GNU sed
# - GNU grep
# - GNU awk
# - GNU tar
# - gzip, bzip2 and xz
# - GNU Make
# - Bash
# - The patch command
# - On Linux, stdenv also includes the patchelf utility üßê
```

#### `TIL: Environment Variables Available during Build & Install phases`
```sh
# $name                 - is the package name
# $src                  - refers to the source directory
# $out                  - PATH to the location in the Nix STORE where the package will be added
# $system               - system that the package is being built for
# $PWD and $TMP         - both point to a TEMPORARY BUILD DIRECTORIES
# $HOME and $PATH       - point to NONEXISTENT directories, so the build CANNOT RELY on them
```

#### `src = ./.;`
```yaml
- Supplies the Location of the Source Files, Relative to flake.nix
```

#### `unpackPhase = "true";`
```yaml
- When a flake is accessed for the first time
  - Repo contents are fetched in the form of a Tarball
  - unpackPhase == We want the Tarball to be UnPacked
```

#### `buildPhase = ":";`
```sh
# This is a no-op or "do nothing" command
```

#### `flake-utils.lib.eachDefaultSystem (system: ...`
```yaml
- If we want the package to be Available for Multiple Systems 
  - e.g., ‚Äúx86_64-linux‚Äù, ‚Äúaarch64-linux‚Äù, ‚Äúx86_64-darwin‚Äù, and ‚Äúaarch64-darwin‚Äù
  - We need to DEFine the OUTput for EACh of those SYStems

- Often the definitions are identical, apart from the NAME of the SYStem
  - eachDefaultSystem function uses a variable for the system name
- The function then iterates over all default systems to GENERATE the OUTPUTS for EACH one
```

#### `Many Flavours of using Flakes`
```yaml
- 1/ A Git repository: git+https://github.com/NixOS/patchelf
- 2/ A specific branch of a Git repository: git+https://github.com/NixOS/patchelf?ref=master
- 3/ A specific revision of a Git repository: 
  - git+https://github.com/NixOS/patchelf?ref=master&rev=f34751b88bd07d7f44f5cd3200fb4122bf916c7e
- 4/ A tarball: https://github.com/NixOS/patchelf/archive/master.tar.gz
```

#### `How do I Check the Package License?`
```sh
# nix-env -qaA nixpkgs.vim --json | jq '."nixpkgs.vim".meta.license'
```

#### `How do I Fetch the Source Tarball and Link it in the Current Directory?`
```sh
# nix-build '<nixpkgs>' -A vim.src
```

#### `How do I Query a Nix Package for its Versions & Revision numbers?`
```sh
# https://lazamar.co.uk/nix-versions/
```
